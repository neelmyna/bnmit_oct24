https://github.com/neelmyna/bnmit_oct24

1. Create github account and login
2. Create new Repo Name: <yourname_python_oct24>
3. Create folder software in C drive and dedicated folders to save the installer files
4. Download the following Apps
	1. notepad++ (faster and easier way to make notes)
	2. vs code (easiest IDE to use)
	3. mysql
	4. python
5. Create PAT in github
	Click on Top Right profile icon
	In the menu (pops up), scroll down and Click settings
	In the new page, Scroll down and Click Developer settings (bottom left)
	In the new page, on top left, Click Personal Access Tokens -> Select Tokens(Classic)
	Now Click Generate new Token -> Select Generate new Token(Classic)
	Enter password if prompted
	Select Expiry -> NO Expiry
	Leave all other settings as it is. Scroll Down and Click Generate Token
	Copy the PAT and mail/whatsApp it to your self
6. Create a folder learning
	sub folder python_learning
	Go inside this folder and open the command prompt
7. Download and install git
8.  git config --global username "<your_github_username>"
	git config --global email "<your_email>"
9. If we wish to download somebody's (anybody's) repo then the command is:
	git clone <git_repo_url>
9. To Sync our Repo and the repo folder in our machine(laptop) the command is:
	git clone https://PAT@github.com/<username>/<repo_name>
10.
HOW TO USE GITHUB:
To update changes in the local repo
$> git add .
$> git commit -m "day1 learning programs and notes"
(+ "message in the box" click commit)

Sync local repo to the remote repo
$> git pull origin main
$> git push origin main
(sync button and click ok when it prompts)

Why in Pyhton there is no implicit cast?
-----------------------------------------
# Program to check if a number if Even

print('Enter a number to check if it is Even: ')
input_num = int(input())

if input_num % 2 == 0:
    print('Input number', input_num, ' is Even')
--------------------------------------------
# Program to check if a number if Even or not.

print('Enter a number to check if it is Even: ')
input_num = int(input())

if input_num % 2 == 0:
    print('Input number', input_num, ' is Even')
else:
    print('Input number', input_num, ' is not Even')
------------------------------------------------
# Program to check if a number if Even or Odd.

print('Enter a number to check if it is Even: ')
input_num = int(input())

if input_num % 2 == 0:
    print('Input number', input_num, ' is Even')
else:
    print('Input number', input_num, ' is Odd')
---------------------------------------------
'''
Accept average score from the user and print the result as follows.
0  - 50 Fail
51 - 75 SC
76 - 90 FC
91 - 100 Distinction
Also check for Invalid score
'''

average_score = int(input('Enter your average score to print your result: '))

if average_score >= 0 and average_score <= 50:
    print('Fail')
elif  average_score <= 75:
    print('Second Class')
elif average_score <= 90:
    print('First Class')
elif average_score <= 100:
    print('Distinction')
else:
    print('Invalid Input')

# x++ != y && --y > z || y++ <= x
-----------------------------------------------------
i = -1
i -= -1 # i = i - (-1) = -1 + 1 = 0
print(i)
------------------------------------
p4.py
import random

player_number = int(input('Enter a number of your choice between 0 to 9: '))

system_number = random.randint(9, 10)
print(system_number)

if player_number == system_number:
    print('You are crorepati')
else:
    print('You are Roadpati')
----------------------------------------------
ASSIGNMENTS:
5. Check if the year is Leap year
6. Check if the input digit is Composite number
7. Check if the character is only a alpha-numeric

Examples of Functions:
print()
len()
type()
sorted()
max()
min()

When to call a function as method:
obj.method()
str.upper()
list1.sort()

The range() function
range(end_value)
range(start_value, end_value)
range(start_value, end_value, increment)

*** In Python we do not have the concept of Function Overloading
range(10)
0, 1, .... 9 [default increment is 1]
range(2, 15)
2, 3, ..... 14 [default increment is 1]
range(5, 25, 3)
5, 8, 11, 14, 17, 20, 23 [manual/over-ridden increment is 3]
range(5, 20, -1)
Returns nothing
range(25, 2, -2)
25, 23, 21, .... 3 [manual increment of -2 or decrement of 2]

for i in range(1, 21):
    i += 2
    print(i)
# 3, 6, 9, .... 18 (our prediction)
# 3, 4, 5, ... 22 (actual o/p)

O/P Formating using Format specifiers in C
%f %s %d %x %X %o
%4d
%-5d
%06d

p8.py
Print the Math tabl of a number for multiples upto 20
input_number = int(input('Enter a number to print its Math table: '))

for i in range(1, 21):
    #print(input_number, '*', i, '=', input_number * i)
    print('%2d * %02d = %03d'%(input_number, i, input_number*i))

'''
12 * 1 = 12
12 * 2 = 24
'''
-------------------------------------------------
9. Accept a number and find sum of digits of the number
10.Accept a number and find count the number of digits in it.
11.Accept a number and find biggest/smallest digit in the number
12.Find sum of Even/Odd digits in the number
13.Find the frequency of a digit in the number

14.Find sum of Odd placed Even digits in the number
15.Find 2nd smallest digit in the number
16.Accept a number from user and find her lucky digit, where the lucky digit is found by finding sum of the digits of the number until a sigle digit number is reached. Thus if the sum is not a single digit number, apply the logic of finding sum of the digits on it.
input_number = int(input('Enter a number to find your lucky digit: '))

sum_of_digits = 0
temp_number = input_number

while temp_number > 0:
    remainder_digit = temp_number % 10
    temp_number = temp_number // 10
    sum_of_digits += remainder_digit
    if temp_number == 0 and sum_of_digits >= 10:
        temp_number = sum_of_digits
        sum_of_digits = 0
print(f'Your lucky digit is {sum_of_digits}')
--------------------------------------------------------
DAY3 WEDNESDAY 23-10-2024
HOW TO SOLVE A PROBLEM

1. Understand the problem. Recognise the required data (I/P). Isolate/remove the unwanted information and data. Focus on the relevant information. Accertain what should be the O/P.
Outcome: We know the I/P, O/P and the relevant information

2. Build the solution using trial and error technique or mathematical formula or using a specific Algorithm. In this step we must not even think of programming.
OutCome: We know the what is the solution(s)

3. Write the Algorithm. Every step of the algorithm must be simple, unambigious and finite.
OutCome: We have a clear visible solution as a procedure

4. Write the Fake-code (Pseudocode) 
OutCome: You have a solution that looks like a code

5. Code it (via the languiage syntax)

6. Good coding practices, naming standards, documentation, unit-testing

7. Efficiency of algorithms, Optimization, development, DEvOps, Cyber Security, Installation, Maintainance

SRP
i++
j--
a[i] = b[j]
b[j]++

a[++i] = b[--j]++

Write a program in Python to check if a number is Perfect Square

45   6.6   6   36
121  11.0  11  121

1. Read N
2. find ROOT_WITH_PRECISION of N
3. find floor of ROOT_WITH_PRECISION as ROOT
4. if ROOT * ROOT is N
	then declare N as P S
	else declare N as not a P S
	
Read N
root = square_root(N)
root = floor(root)
if root * root is N then
	print N is P S
else
	print N is not a P S
	
string

1111 1111
f    f
ff
15*16(1) + 15*16(0)
=240 + 15
=255

10
100
1011

17. Accept a string and access all the characters one by one
my_string = input('Enter a place name: ')

print(f'Type of {my_string} is {type(my_string)}')

for character in my_string: # for each loop
    print(f'{character}, Type={type(character)}')

first_character = chr(my_string[0])
print(f'first charatcer = {first_character}, Type = {type(character)}')
----------------------------------------------
18.
my_string = input('Enter a place name: ') # mumbai

my_string = my_string.upper()
print(f'my_string = {my_string}')
#print(f'string1 = {string1}')

# print(f'String in Upper case = {my_string.upper()}')
----------------------------------------
19.
number1 = 15
number2 = 25.5

print(f'type of number1 = {type(number1)}')
print(f'type of number2 = {type(number2)}')

print(number1.bit_count)
print(number1.__sizeof__())
print(number1.__eq__(15))
-----------------------------------------
20.
my_str = 'bengaluru'

print(my_str[0])   # b
print(my_str[1])   # e
print(my_str[-1])   # u
print(my_str[-2])   # r
print(my_str[-12])   # IndexError
print(my_str[100]) # IndexError
-----------------------------------------------
21.
# String Slicing

my_str = 'bengaluru'
print(my_str[:])
print(my_str[::])

print(my_str[1:8])   # engalur
print(my_str[2:6:2]) # na
print(my_str[::2]) # bnauu
print(my_str[::-2]) # uuanb
print(my_str[::-1]) # urulagneb
--------------------------------------------
22.
# String Slicing

my_str = 'bengaluru'

print(my_str[:20:1]) # No error
print(my_str[20:-20:1]) # empty string
print(my_str[20:-20:1]) # complete string in reverse
---------------------------------------------------------
23.
my_str = 'banashankari'

print(my_str.find('s')) # 4
print(my_str.find('m')) # -1
print(my_str.find('shankari')) # 4
print(my_str.find('a', 3)) # 3
print(my_str.find('na', 1, 4)) # 2
print(my_str.find('na', 1, 3)) # -1
----------------------------------------------------
24.
my_str = 'banashankari'

print(my_str.index('s')) # 4
print(my_str.index('shankari')) # 4
print(my_str.index('a', 3)) # 3
print(my_str.index('na', 1, 4)) # 2
print(my_str.index('na', 1, 3)) # error
print(my_str.index('m')) # error
---------------------------------------------------
Arithmetic Operators:
+ - * / %
All are binary operators
Used with Infix Notation
Input are numbers
Output is number
Type of both the operands must be same
2 + 17 - 15
Arithmetic operators/operations have Left to Right Associtivity
2 - 17 * 15
The higher precedence operators/operations happens 1st, even though the operator appreas lately in the arithmetic expression. In the above expression, 17 * 15 is calculated 1st.
The intermediatre result of an arithmetic expression is stored in the special purpose register named "Accumalator"

34 + 45
34 + (-45)

25 + 25.55


num1 = 34
num2 = -45

0010 0010
1 * 2(5) + 2
= 32 + 2 
= 34

HOW NEGATIVE NUMBER IS STORED:
Now take -45
take its absolute
take its 2's Compliment
0010 1101
1101 0010

1101 0011
-1 * 2(7) + 1 * 2(6) + 16 + 3
-128 + 64 + 19
-64 + 19
= -45

25.
Find the biggest of 3 distinct numbers

input_num1 = int(input('Enter 1st number: '))
input_num2 = int(input('Enter 2nd number: '))
input_num3 = int(input('Enter 3rd number: '))

if input_num1 > input_num2 and input_num1 > input_num3:
    print(f'Num1 = {input_num1} is the biggest number')
elif input_num2 > input_num3:
    print(f'Num2 = {input_num21} is the biggest number')
else:
    print(f'Num3 = {input_num3} is the biggest number')
------------------------------------------------
26.
Find sum of the series:
n + n2 + n3 + upto 10 terms
27.
Find sum of the series:
1 - n + n2 - n3 + upto M terms
28.
Find sum of the series:
1 - n/3 + n2/5 - n4/7 + n8/9 ....
(1<n<5 and 1<m<10)
29.
Print the Nth Prime number
30.
Check if the sum of Prime digits in a number is a Prime number
31.
Print Nth term of the following series:
1 2 2 3 3 5 5 7 8 11 13 13
---------------------------------------
Find sum of Even Placed Odd Digits in a number
1. Read NUM
2. if NUM is less than 10 then
	Print Result = NUM
3. else do the following:
	sum1 = 0 
	sum2 = 0
	count_of_digits = 0
	switch = true
	while NUM is greater than Zero:
		remainder_digit = NUM // 10
		if switch:
			sum1 += remainder_digit
		else:
			sum2 += remainder_digit
		switch = !switch
		count_of_digits += 1
	if count_of_digits % 2 == 0:	
		Result = sum2
	else:
		Result = sum1
---------------------------------------------------
# Find sum of the series:
# n - n2/3 + n4/5 - n8/7 .....
# (1<n<5 and 1<m<10)
'''
n = int(input('Enter the N value: '))
m = int(input('Enter numbers of terms in the series: '))
# check for invalid input data
if (n <= 1 or n >= 5) and (m <= 1 or m >= 10):
    print('Invalid data entered')
    exit('End of Program')

# For valid input data:
sum = 0
for i in range(m):
    sum += (n ** 2 ** i) / (2 * i + 1) * ((-1) ** i)
    print('sum = ', sum, 'i = ', i)

print('Sum of the terms is ', sum)
--------------------------------------------------
31.
Find Nth term of combined series:
1 2 2 3 3 5 5 7 8 11 13 13

--------------------------------------------------
32. Check if a number is a Palindrome
33. Find sum of 1st and last digits of a number
34. Print Nth digit of a number (starting from Left)
35. Print Nth digit of a number (starting from Right)
36. Accpet the number of Lines from the user and print the following shapes:
37. Right Angled Triangle
38. Equilateral Triangle
39. Square
40. Empty Square
41. Empty Equilateral Triangle
42. Empty Rhombus
43. Hexagon
44. X shape
45. X shape inside Empty Square
46. Pascal Triangle
--------------------------------------------------
47
my_str = 'banashankari'
sub_string = 'm'

try:
    print(my_str.index('s')) # 4
    print(my_str.index(sub_string)) # error
    print(my_str.index('shankari')) 
except ValueError as e:
    print(f'The sub string {sub_string} not found')
    print(e.__str__())
except:
    print('Some error occured')
--------------------------------------------------
DAY4 THURSDAY 24-10-2024

List DS in Python:

It is simplest DS in Python
All elements of the list are stored in contigious memory locations.
The List grows and shrinks dynamically
List is ordered (we use subscript [] to access list elements)
List is mutable
Lists are passed to functions by reference
For the user, lookup(accessing), addition and deletion of elements is O(1) efficiency.
We can create lists inside list
list provides lot of methods such as append(), insert(), pop() remove(), sort()
We can do list slicing
-------------------------------
numbers1 = []
numbers2 = list()
numbers3 = [1, 2, 3, 4, 5]
numbers4 = list(numbers3)
numbers5 = list(numbers3[1:4])

print(numbers1)
print(numbers2)
print(numbers3)
print(numbers4)
print(numbers5)
------------------------------------
input_size = int(input('Enter size of the Array: '))
numbers = []
for i in range(input_size):
    number = int(input())
    numbers.append(number)
    # numbers.append(int(input()))

print('The array is: ', numbers)

print(f'The array of size {input_size} is:')
for number in numbers:
    print(number, end='  ')
----------------------------------------------------
print('Enter space seperated numbers in a line')
user_input = input()
print(type(user_input))
----------------------------------------------------
numbers = [int(number) for number in user_input.split()]
print('The array is: ', numbers)

import sys
# Command line Args
# Find biggest and smallest numbers among the numbers given by user

print('User given numbers are: ', sys.argv)

----------------------------------------------------
print('Enter space seperated numbers in a line')

numbers = [int(number) for number in input().split()]
print('The array is: ', numbers)
----------------------------------------------------
Download MySQL:
Create a folder named "mysql" in C:\software
G search: Download MySQL
open: https://www.mysql.com/downloads/
Scroll down and click: MySQL Community (GPL) Downloads 
Click: MySQL Installer for Windows
Observe the version 8.0.xx
Download the msi file of size 3xx MB
Now, cut and paste the installer file from downloads folder to C:\software\mysql

Installation of MySQL:
Double Click the installer file
	Choosing the setup File: (check box) Full -> Click Next
	Installation: Click Execute -> Click Next
	Product Configuration: Click Next
	Type and Networking: Do not change the settings (remember the port number 3306) Click Next
	Authentication Method: (No changes) Click Next
	Accounts and Rolls: Add the Root Password as "root123" -> Click Next
	Windows service: Click Next
	Server File Permissions: Click Next
	Apply Configurations: Click Execute -> Click Finish
	Product Configuration: Click Next
	MySQL Router Config: Click Finish
	Product Configuration: Click Next
	Connect to Server: Enter password and Click Check (Connection succeeded must appear)
	Apply Configurations: Click Execute -> Click Finish
	Product Configuration: Click Next
	Installation Complete: Click Finish
----------------------------------------------------
C:\Program Files\MySQL\MySQL Server 8.0\bin

Paste this path in Environment variables, so that the CLI "mysql" is recognised globally.

Windows search: env
Click on Edit system environment variables
Click environment variables
On the top double click path
Click new
Ctrl+V (paste) the path
Click Ok Ok OK
--------------------------------------------------------------
show databases;
// To display the available databases

use nithin_db;
// To select (go inside) the database

select database();
// To print the current DB

create database my_new_db;
// To create a new DB

drop database nithin_db;
// To delete the database (All the content of the DB will be deleted)

Lets take an entity: employee

The table name must be employees
Whle creating a table, we must povide 3 details of the attributes of the entity
	1. name
	2. data type
	3. constraint
Attributes: id, name, designation, location, phone_number, salary, commision, years_of_experience

create table IF NOT EXISTS employees(
id						int				primary key  auto_increment
name					varchar(30)		not null
designation				varchar(30)		not null
location				varchar(30)		
phone_number			bigint			unique
salary					float			default (0)
commision				int				
years_of_experience		tinyint			);


delete * from employees;
truncate table employees;
drop table employees;
-----------------------------------------------------------------------
DAY6 SATURDAY 26-10-2024

ALGORITHMS:

Category: Brute force, Divide and Conquer, Decrease and Conquer
Some algorithms among these may also be catagorised as comparision based.

Linear Search  (Brute force and comparision based)
Binary Search  (Divide and Conquer)
Bubble Sort    (Brute force and comparision based)
Insertion Sort (Decrease and Conquer and comparision based)
Quick Sort     (Divide and Conquer and comparision based)
*Merge Sort     (Divide and Conquer and comparision based)
*BST            (Divide and Conquer)
*AVL Tree       (Divide and Conquer and comparision based)

How the Algorithm works
Pseudocode of the logic
Implementation (Code)
Efficiency
Optimization
Application of the algorithm
Category

LINEAR SEARCH

In a list or array of elements, we search for an element sequentialy from either of the ends and move towards another end.

Possibilities:
1. We notice that the element may be found at the very 1st position or it may be found some where near the 1st element.
2. We may find the element some where at the middle of the list.
3. We may find the element some where at the rear end of the list.
4. However, we may also have the situation where the element is not found.

The above scenario is the case where we are searching for the 1st occurance of the element.

Alternatively, we may have to find the 2nd occurance of the element.
We may have to find the frequency of the element.

In the 1st possibility, the number of searches is 1 or nearer to 1.
In the 2nd possibility, the number of searches is N/2 or nearer to N/2, where N is the size of the list.
In the 3rd possibility, the number of searches is N or nearer to N, where N is the size of the list.
In the 4th possibility, the number of searches is exactly N.

BIG-OH NOTATION:
1. It is used to find worst case efficiency of an algorithm.
However, we cn also find the best case and average case efficiencies as well.
2. Big-Oh finds the efficiency in terms of N, where N is the size of the data structure (list, tree etc)
3. Big-Oh considers the size N to be very big.
Because we have to find efficiency of bigger size than the smaller sized data structures. This is because, for smaller sized data structures, the computers are equipped to find the solution faster/quicker. However how the computer or the algorithm behaves for very large data structures is the study of interest.
4. Big-Oh gives us only the order in which the efficiency is. It doesn't give the exact efficiency. For example, Log(N), Root(N), N!, N, N*Log(N), N-square etc.
This is because its duty is to tell us the order in which the efficiency. To find exact efficiency means, we are finding the efficiency for an instance/example/specific problem.
5. The efficiency of any algorithm depends on the total number of iterations of the loops or recursive calls.

PSEUDOCODE OF LINEAR SEARCH:

Procedure: linear_search:
Receives the list/array and search_element
	N = sizeof(list)
	for POSITION from 1 to N do:
		if element at POSITION in list is equal to search_element:
			then return POSITION
	return -1 ###Comment: indicating search_element was not found
	
Python Program:
import sys

def linear_search(my_list, key):
    for i in range(len(my_list)):
        if my_list[i] == key:
            return i
    return -1

numbers = list()
print(type(sys.argv))

for i in range(1, len(sys.argv)):
    numbers.append(float(sys.argv[i]))

print(f'User given numbers are: ', numbers)
key = float(input('Enter number to be searched: '))

position = linear_search(tuple(numbers), key)
if position == -1:
    print(f'The element {key} was not found')
else:
    print(f'The element {key} was found at position {position+1}')
-----------------
Worst case scenario: When the element is not found, then number of searches is N (that is the number of elements in the list)
The number of searches is N even when the element is found at last position or some where near last position.
In these 2 cases, the efficiency is O(N)
Thus, WCE of Linear search is O(N)

The best case scenario is when the number of searches is 1 or nearer to 1.
Thus, BCE  is O(1)
The ACE looks to be O(N/2), but it is not. Because, we know that the Big-Oh job is not to give the exact efficiency or in other words, its job is to tell only the order in which the efficiency is.
Hence, ACE of linear search is O(N)

WCE: O(N)
ACE: O(N)
BCE: O(N)

How to optimize Linear Search:
1. Pridictions: See if we can predict accurately that the search element is in some part of the list, like the 1st half or 2nd half etc.
2. Use MultiThreading. Cut the list into M number of sub lists and fee each of them to the M threads where every thread is implementing linear search. This method brings down the search time by M times.

APPLICATIONS:
We must use Linear search when the input list is not sorted. We must use linear search even when the list is almost sorted!

CATEGORY:
It falls under Brute Force technique. Brute Force technique is the natural/traditional way of solving a problem. It doesn't follow/implement any specific formula nor it uses partially another algorithm.
--------------------------------------------------------------------
BINARY SEARCH:

Mandatory Pre-Requisite: It expects the list to be sorted. The list elements must be ordered so that random access of elements can be done (can be implemented on arrays only. not on linked lists)

Algorithm:
For a list of size N, We reach the mid element and check if it is the key. If yes, then stop the search and return the mid position where the key is found.
Else, we check if the key is smaller than the mid element, then we are affirmed that the key cannot be found in the 2nd half (right half) of the list.
Thus, we adjust the search area to 1st half.
If the key is bigger than the mid element, then the search area is reset to 2nd half.
This is continued until we are left with a single element list!
We keep moving to the left when the key is smaller and we keep moving to the right when the key is nearer or equal to the rear element.
When the key is not found even in the single element list, then the search fails.

PSEUDOCODE:
procedure: binary_search(my_list, key):
	low  = 1 (The 1st position of list)
	high = N (The last position of list)
	do: ###Comment: We must use do-while loop if available (not while loop)
		mid = (low + high) / 2  ###Comment: Integer division
		if list[mid] is key then:
			return mid
		else if key < list[mid] then:
			set high = mid-1 ###Comment: reset search list to 1st half
		else:
			set low = mid+1 ###Comment: reset search list to 2nd half
	return -1 ###Comment: When the key is not found
	
Implementation:
import sys

def binary_search(my_list, key):
    low = 0
    high = len(my_list)-1
    while low <= high: # until list has at least one element
        mid = (low + high) // 2
        if key == my_list[mid]:
            return mid
        elif key < my_list[mid]:
            high = mid - 1
        else:
            low = mid + 1
    return -1

numbers = list()
print(type(sys.argv))

for i in range(1, len(sys.argv)):
    numbers.append(float(sys.argv[i]))

key = float(input('Enter number to be searched: '))
numbers.sort() #mutable call
print(f'User given numbers are: ', numbers)

position = binary_search(tuple(numbers), key)
if position == -1:
    print(f'The element {key} was not found')
else:
    print(f'The element {key} was found at position {position+1}')
----------------------------------------
EFFICIENCY OF BINARY SEARCH:

We implement Binary search using do-while loop. Thus, it is not possible to know the number of iterations directly. Because, the loop condition is not on N. Where as, in for loop, the loop condition always involves N (size of the list)
Hence we have to find efficiency of Binary search indirectly.

Let us assume number of iterations of do-while loop is X.
We know,
the number of elements in 1st iteration is N
the number of elements in 2nd iteration is N/2
the number of elements in 2nd iteration is N/4

Observe that, when there is only one element in the list, the low is equal to high and the value would be 0 (if it is 1st element of given list) or N-1 if it is the last element.

N      N/2      N/4      N/8   ......       4        2       1
2pow(X-1)                                 2pow2    2pow1   2pow0

N = 2pow(X-1)
According to Big-Oh characteristic, we can ignore the constants.
Thus,
N = 2powX
Hence X = Log(N)
And thus WCE of Binary Search is O(Log(N))
ACE: O(logN)
BCE: O(1)

Optimization: The same steps we used to optimize linear search.

Apllication: Where ever searching is necessary, we must use binary search if the list is sorted.
Note that Log(N) efficiency is the fastest.

If we have to search 1 lakh elements, say the elements are 1, 2, 3, ... 100000
And the key is 99999
Then the number of searches with linear search algorithm is 99,999
And number of searches with Binary search would be around 20!!!!!!
-----------------------------------------------------------------------
QUICK SORT:

PARTITION step: O(N) algorithm
i = 0   ## 'i' runs for the length of the list
We take either the 1st or last element (in fact any) as reference element named 'pivot'
j = 0  ## 'j' tracks the final position of pivot element.
Once we have accessed all elements of the list, and the pivot element is placed in its final position, the list is PARTITIONED into 2. Where the left part will have all the elements smaller than the pivot and all elements to the right which are greater than or equal to the pivot element.
----------------------
import sys

def partition(my_list):
    j = 0
    pivot = my_list[-1] #last element is the reference element
    for i in range(len(my_list)-1):
        if my_list[i] < pivot:
            my_list[i], my_list[j] = my_list[j], my_list[i]
            j += 1
    my_list[j], my_list[-1] = my_list[-1], my_list[j]

numbers = list()
print(type(sys.argv))

for i in range(1, len(sys.argv)):
    numbers.append(float(sys.argv[i]))

print(f'User given numbers are: ', numbers)
partition(numbers)
print(f'After Partition, list is: ', numbers)
------------------------------------------------------
import sys

def partition(my_list, low, high):
    j = low
    pivot = my_list[high] #last element is the reference element
    for i in range(low, high):
        if my_list[i] < pivot:
            my_list[i], my_list[j] = my_list[j], my_list[i]
            j += 1
    my_list[j], my_list[high] = my_list[high], my_list[j]
    return j

def quick_sort(my_list, low, high):
    if low < high:
        pivot_index = partition(my_list, low, high)
        quick_sort(my_list, low, pivot_index-1)
        quick_sort(my_list, pivot_index+1, high)

numbers = list()
print(type(sys.argv))

for i in range(1, len(sys.argv)):
    numbers.append(float(sys.argv[i]))

print(f'User given numbers are: ', numbers)
quick_sort(numbers, 0, len(numbers)-1)
print(f'Sorted list is: ', numbers)
-------------------------------------------
Efficiency of Quick Sort:
The quick_sort() recursive call has efficiency of O(LogN)
The Partion step has efficiency of O(N)
Thus the Quick Sort efficiency is O(N LogN)
BCE: O(N Log N)
ACE: O(N Square)
WCE: O(N Square)

NOTE:
1. In all sorting techniques/algorithms, the best case scenario is when the list is already sorted or almost sorted and we are sorting in the same order.

2. In  all sorting algorithms, the worst case scenario is when the list is sorted or almost sorted and we are sorting in the opposite order.

w.r.t. Quick sort, in the best case scenario, the pivot would exactly partition the list into 2 HALVES in every recursive call.
Thus the number of partitions would be LogN

However, in the worst case scenario, the pivot would partition the list with only one element or very few elements on one side and on the other, all remaining elements.
This requires N partitions to be done. Hence the total efficiency of Quick sort in the worst case would be O(N square)

OPTIMIZATION:
One way to optimize the Quick sort is to study which of the element in the list to be choosen as pivot, so that the list partitioning creates balanced part lists.

Application:
When the list to be sorted is having random elements (where the sorted prediction is impossible) then it is good to apply Quick Sort.
We must not apply quick wort when we know the input list is sorted and we have to sort in reverse order.

CATEGORY: Quick sort belongs to Divide and Conquer technique.
Remember, in all divide and conquer techniques, we apply the same logic to the divided (part) data structure.
----------------------------------------------------------
INSERTION SORT:

It is said to be an Optimistic Sorting technique.

Even before starting the sorting, we perceive Sorted array in the I/P array!

Thus we see 2 arrays in the given array. One, the sorted array and the other, unsorted array.

The very 1st element of the given list is itself considered to be a list and we all know that a single element list is always sorted. And the remaining elements are to be sorted (unsorted array).

Thus, we have to keep inserting/adding one element at a time from the unsorted list to the sorted list.
However, this is not that easy as it sounds!
We must INSERT the new element into the sorted list in its right position.

PSEUDOCODE:

'i' is considered to point to the indices of the array which starts from zero

for i from 1 to N-1 do:
	element = array[i] ### element to be inserted from unsorted to sorted A
	j = i-1 ### index of last element in the sorted array
	while j >= 0 and element < array[j] do:
		array[j+1] = array[j] ### Shift the element to right in sorted Array
		j--
	array[j+1] = element
	
Note:
1. the outer loop of the Insertion sort (And also of bubble sort and selection sort) runs for the length of unsorted array
2. The inner loop of Insertion sort shifts the elements in the sorted array to the right making place for the new element to be inserted.
3. When the new element to be inserted in the sorted list happens to be the biggest element in the sorted list, then there are no shifts!
4. When the new element to be inserted in the sorted list happens to be the smallest element in the sorted list, then there maximum possible number of shifts.
5. In the case where the list is already sorted (almost sorted), then the number of shifts for every new element will be either zero or nearer to zero. In such case, we observe that the Insertion sort is working as if we are copying elements of a list into another. And thus, the BCE of Insertion sort would be O(N) (linear)
----------------------------------------------------------------
DAY7 MONDAY 04-11-2024

When ever we install python, we get 2 CLIs (commands, nothing but the Apps)
python: It is used to run/debug python scripts
pip:    It is used to install/uninstall packages

$ pip list
The above command lists all the packages installed

$ pip install pymysql
The above command installs the package pymysql
pymysql is used to do database programming such as connectivity and run the various commands such as CRUD and lot more.
------------------------------------------------------------
#   DATE	DAY3  DURATION START-TIME
1	21-10	Mon		2.5		3:30
2	22-10	Tue		2.5		3:30
3	23-10	Wed		4		1:30
4	24-10	Thu		2.5		3:30
5	25-10	Fri		2.5		3:30
6	26-10	Sat		2.5		3:30
7	04-11	Mon		2.5		3:30
8	05-11	Tue		2		4:00
9	06-11	Wed		2.5		3:30
10	07-11	Thu		2.5		3:30
11	08-11	Fri		2.5		3:30	1st Assessment
12  10-11   Sun     3       9 am to 12 pm (Online)
13	11-11	Mon		2.5		3:30
14	12-11	Tue		2.5		3:30
15	13-11	Wed		2.5		3:30
16	14-11	Thu		2.5		3:30
17	15-11	Fri		2.5		3:30	2nd Assessment
18	16-11	Sat		4		9 am to 1 pm (Online)
--------------------------------------------------------
Merge Sort
IP Array:  23  45  87  12  9  35  55  25  7

Divide Steps:
23  45  87  12        9  35  55  25  7
23  45        87  12        9  35        55  25  7
23      45       87       12       9      35      55     25  7
23      45       87       12       9      35      55     25       7

Conquer Steps:
23  45        87       12       9      35      55     25       7
			  
23  45      12  87        12       9      35      55     25       7
				         			  
23  45     12  87      9  12       35      55     25       7
						           35  55
23  45     12  87      9  35       55       25        7
								   25  55        7
23  45     12  87      9  35      25  55        7
i=2        j=2

12  23  45  87       9  35      25  55        7
                     i=0        j=0
					 
					 9  25  35  55        7
					 k=0
12  23  45  87       9  25  35  55        7
i=3                  j=4

9  12  23  25  35  45  55  87        7
k=7

9  12  23  25  35  45  55  87        7
i=0                                  j=1

7  9  12  23  25  35  45  55  87
k=0

Algorithm:

def mergeSort(array, low, high):
	if low < high:
		array1 = mergeSort(array, low, high//2);
		array2 = mergeSort(array, high//2+1, high);
		mergedArray = merge(array1, array2)
	return mergedArray

def merge(array1, array2):
	i = 0
	j = 0
	mergedArray = []
	while i <= len(array1) or j <= len(array2):
		if array1[i] < array2[j]:
			mergedArray.append(array1[i])
			i += 1
		else
			mergedArray.append(array2[j])
			j += 1
	
	mergedArray.extend(array1[i:])
	mergedArray.extend(array1[j:])
			